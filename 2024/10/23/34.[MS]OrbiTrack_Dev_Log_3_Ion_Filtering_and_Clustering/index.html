<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>OrbiTrack Dev Log 3: Ion Filtering and Clustering - 太平塔</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta name="description" content="After m&#x2F;z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m&#x2F;z values. To ensur">
<meta property="og:type" content="article">
<meta property="og:title" content="OrbiTrack Dev Log 3: Ion Filtering and Clustering">
<meta property="og:url" content="http://envhyf.github.io/2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/index.html">
<meta property="og:site_name" content="太平塔">
<meta property="og:description" content="After m&#x2F;z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m&#x2F;z values. To ensur">
<meta property="og:locale">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_1.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_2.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.DBSCAN_algorithm_results.png">
<meta property="og:image" content="http://envhyf.github.io/images_rele/Fig.Orbitrak_ion_check_on_individual_window.png">
<meta property="og:image" content="http://envhyf.github.io/images_rele/Fig.Orbitrack_ion_mapper_demo.png">
<meta property="article:published_time" content="2024-10-23T16:45:00.000Z">
<meta property="article:modified_time" content="2025-08-05T22:40:28.752Z">
<meta property="article:author" content="Hao Yufang">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Orbitrap">
<meta property="article:tag" content="Mass Spectrometry">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_1.png">





<link rel="icon" href="/bugcatcher.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-dark.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116955364-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-116955364-1');
</script>


    


<meta name="generator" content="Hexo 6.1.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    太平塔
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories/Research">Research</a>
            
            <a class="navbar-item "
               href="/categories/Tech">Tech</a>
            
            <a class="navbar-item "
               href="/categories/Life">Life</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Buscar" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/envhyf/">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            OrbiTrack Dev Log 3: Ion Filtering and Clustering
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2024-10-23T16:45:00.000Z" itemprop="datePublished">10月 23 2024</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Research/">Research</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 de lectura (Alrededor de 2335 palabras)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>After m/z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m/z values. To ensure robust clustering, it’s important to first remove rare or noisy ions that could interfere with pattern recognition.</p>
<span id="more"></span>

<h2 id="1-Basic-principle"><a href="#1-Basic-principle" class="headerlink" title="1. Basic principle"></a>1. Basic principle</h2><p>We apply two types of filtering strategies onto Orbitrap MS1 data to isolate meaningful signals.    </p>
<p><strong>Density-Based Filtering (KDE)</strong><br>Kernel Density Estimation (KDE) is used to evaluate the local density around each m/z value:</p>
<ul>
<li>Low-density points are likely to represent noise or isolated random signals and are filtered out using a user-defined percentile threshold (default: 5%).</li>
<li>To balance accuracy and computational performance, the full m/z range is dynamically split into smaller chunks (e.g., 500 points), and KDE is applied to each chunk independently.<br>(Note: Since KDE has a time complexity of O(n²), chunking significantly reduces the computational burden. See slides below for more details.)</li>
</ul>
<p><img src="/images/Orbitrack_log/Fig.KDE_algorithm_1.png"></p>
<p><img src="/images/Orbitrack_log/Fig.KDE_algorithm_2.png"></p>
<p><strong>Ion Clustering (DBSCAN)</strong><br>The remaining m/z values after KDE filtering are grouped using the DBSCAN algorithm:</p>
<ul>
<li>DBSCAN identifies ion clusters based on spatial proximity, enabling detection of true ion peaks even with minor m/z drifts over time.</li>
<li>After clustering, a frequency threshold (e.g., ≥2% of scans) is applied to exclude unstable or sporadic clusters.</li>
</ul>
<p>For example, if a stable calibrant ion appears consistently in 100 scans, meaningful signals are expected to recur in at least a small fraction (e.g., ≥2 scans). This step removes random spikes that lack temporal consistency.</p>
<p>🟥 Note: The clustering_thre threshold is critical and should be carefully tuned based on the actual dataset and scanning strategy. It is highly recommended to validate the setting by checking the fitting quality in the post-analysis stage.</p>
<p><img src="/images/Orbitrack_log/Fig.DBSCAN_algorithm_results.png"></p>
<p>Besides, since the <code>OrbiTrack</code> will be also used for empowered the TOF peak list, it is </p>
<h2 id="2-Code-library"><a href="#2-Code-library" class="headerlink" title="2. Code library"></a>2. Code library</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">## Module 3 Filtering &amp; Clustering
def mz_start_end_selection(df, start, data_size_threshold, max_mz, max_window_width=2.0, delta_mz=0.5):
    """
    Dynamically determine the m/z end value starting from 'start' such that:
    - The number of ions between start and end reaches data_size_threshold
    - But the window size doesn't exceed max_window_width

    Parameters:
        df: DataFrame with 'corrected_m/z' column
        start: float, m/z start value
        data_size_threshold: int, minimum number of ions in window
        max_mz: float, global m/z limit
        max_window_width: float, max allowed width of m/z window
        delta_mz: float, step size for expansion

    Returns:
        end: float, selected m/z end value
    """
    current_mz_start = start
    current_mz_end = start + delta_mz

    while current_mz_end &lt; max_mz:
        condition = (df['corrected_m/z'] &gt;= current_mz_start) &amp; (df['corrected_m/z'] &lt; current_mz_end)
        current_mz_values = df[condition]

        # If threshold met, return current end
        if len(current_mz_values) &gt;= data_size_threshold:
            break

        # If window exceeds max width, break
        if (current_mz_end - current_mz_start) &gt;= max_window_width:
            break

        current_mz_end += delta_mz

    return min(current_mz_end, max_mz)

def filter_asymmetric_peaks(peaks, props, y_data, left_thre=500, right_thre=500):
    """
    Remove peaks with weak prominence on both sides or very asymmetric shoulder peaks.

    Parameters:
    - peaks: array of peak indices
    - props: properties returned by find_peaks
    - y_data: original signal array (e.g., y_tof)
    - left_thre, right_thre: minimum prominence required on each side

    Returns:
    - filtered_peaks: list of retained peak indices
    """
    filtered_peaks = []
    for i, pk in enumerate(peaks):
        y_pk = y_data[pk]
        left_valley = y_data[props['left_bases'][i]]
        right_valley = y_data[props['right_bases'][i]]

        left_prom = y_pk - left_valley
        right_prom = y_pk - right_valley

        # Keep only if either side is strong enough
        if left_prom &gt;= left_thre or right_prom &gt;= right_thre:
            filtered_peaks.append(pk)

    return np.array(filtered_peaks)
def KDE_DBSCAN_clustering_filtering_in_batch_with_tof_data(df, start, end,
        kde_bandwidth, kde_percentile, eps_value, clustering_thre,
        tof_spectrum, tof_add_ion_threshold):

    # 1. Subset Orbitrap spectrum
    condition = (df['corrected_m/z'] &gt; start) &amp; (df['corrected_m/z'] &lt; end)
    ind_mz_df = df[condition].sort_values(by='corrected_m/z').reset_index(drop=True)
    ind_mz = ind_mz_df['corrected_m/z'].values

    if len(ind_mz) &lt; 2:
        return pd.DataFrame(), pd.DataFrame()

    # 2. KDE filter
    kde = KernelDensity(bandwidth=kde_bandwidth)
    kde.fit(ind_mz.reshape(-1, 1))
    density_scores = np.exp(kde.score_samples(ind_mz.reshape(-1, 1)))
    threshold = np.percentile(density_scores, kde_percentile)
    filtered_mz_values = ind_mz[density_scores &gt; threshold]

    if len(filtered_mz_values) &lt; 2:
        return pd.DataFrame(), pd.DataFrame()

    # 3. DBSCAN clustering
    eps = eps_value * start / 1E6
    min_samples = 1
    db = DBSCAN(eps=eps, min_samples=min_samples).fit(filtered_mz_values.reshape(-1, 1))
    labels = db.labels_

    clusters = {}
    for label in np.unique(labels):
        if label != -1:
            indices = np.where(labels == label)[0]
            cluster_values = filtered_mz_values[indices].flatten()
            centroid = np.mean(cluster_values)
            clusters[centroid] = cluster_values.tolist()

    cluster_filtered = {
        c: v for c, v in clusters.items()
        if len(v) &gt; showing_freq * clustering_thre
    }

    # 4. Orbitrap peaks → unified format
    orbitrap_records = []
    mz_to_intensity = dict(zip(ind_mz_df['corrected_m/z'], ind_mz_df['intensity']))

    # Pull TOF data for the current window
    fit_ind = tof_spectrum[(tof_spectrum['mz'] &gt; start) &amp; (tof_spectrum['mz'] &lt; end)].reset_index(drop = True)
    x_tof, y_tof = fit_ind['mz'], fit_ind['MS_av']

    for centroid, mz_list in cluster_filtered.items():
        int_orbi = np.mean([mz_to_intensity[mz] for mz in mz_list])
        index_tof = (x_tof - centroid).abs().idxmin() if not x_tof.empty else None
        int_tof =   y_tof.iloc[index_tof] if index_tof is not None else np.nan

        orbitrap_records.append({
            'm.z': centroid,
            'int_in_orbi': int_orbi,
            'int_in_tof': int_tof,
            'Note': 'Orbi'
        })

    cluster_df = pd.DataFrame(orbitrap_records)

    # 5. TOF-only peak detection
    
    peaks, props = find_peaks(y_tof, prominence=200, distance=5, width=2)
    filtered_peaks = filter_asymmetric_peaks(peaks, props, y_tof, left_thre=500, right_thre=500)

    peak_mz = x_tof[filtered_peaks]
    ppm_threshold = tof_add_ion_threshold
    missing_records = []

    for peak in peak_mz:
        allowed_diff = peak * ppm_threshold / 1e6
        matched_in_cluster = any(np.abs(cluster_df['m.z'] - peak) &lt;= allowed_diff) if not cluster_df.empty else False
        # matched_in_raw = any(np.abs(ind_mz_df['corrected_m/z'] - peak) &lt;= allowed_diff) if not ind_mz_df.empty else False

        if not (matched_in_cluster):
            # Estimate Orbitrap intensity only if possible
            int_orbi = np.nan
            int_tof = y_tof.iloc[(x_tof - peak).abs().idxmin()]
            missing_records.append({
                'm.z': peak,
                'int_in_orbi': int_orbi,
                'int_in_tof': int_tof,
                'Note': 'Missing Peak'
            })

    missing_df = pd.DataFrame(missing_records)

    # 6. Merge both
    combined_df = pd.concat([cluster_df, missing_df], ignore_index=True)
    if len(combined_df) &lt; 2:
        return pd.DataFrame(), pd.DataFrame()
    combined_df = combined_df.sort_values(by='m.z').reset_index(drop=True)

    
    return combined_df, missing_df<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="3-Execution-and-Output-Parameters"><a href="#3-Execution-and-Output-Parameters" class="headerlink" title="3. Execution and Output Parameters"></a>3. Execution and Output Parameters</h2><h3 id="3-1-Pre-filtering"><a href="#3-1-Pre-filtering" class="headerlink" title="3.1 Pre-filtering"></a>3.1 Pre-filtering</h3><p>Before applying the main filtering and clustering procedures, I noticed that certain segment scans showed abnormally high intensities of primary ions from the ion source — in our case, NaI–Na⁺ as the sodium-adducted NaI. These “spike scans” often featured very strong Na₂I signals, while all other ions were poorly detected, likely due to temporary spray instability or ESI plume fluctuations.</p>
<p>To address this, we define both a <code>Na2I_upper_bound</code> and a <code>Na2I_lower_bound</code>. These thresholds help identify segment scans where Na₂I signal is either abnormally high or too weak (e.g., unstable spray), which is particularly important for online measurements where ion intensity is crucial for interpretation.</p>
<p>Using the pre-defined <code>find_peak_near_mass_after_mzcal</code> function, we search for peak intensities of selected sodium-related masses. If any of them fall outside the defined bounds, we remove all ions from those time points before further processing.</p>
<pre class="line-numbers language-python{%" data-language="python{%"><div class="caption"><span>codeblock lang:python %}</span></div><code class="language-python{%"># Define reference masses related to NaI signals
Na2I_lower_bound, Na2I_upper_bound = 0, 50 * 1E6  # Filter to remove bad air-beam ions
masses = [172.88347, 166.9163, 185.0420]  # Na2I and some other ions if you think are essential
peak_results = {}

# Locate peaks near the reference masses
for mass in masses:
    peaks = find_peak_near_mass_after_mzcal(merged_spectrum_mzcal, mass, tolerance_ppm)
    peak_results[mass] = peaks

# Use one of the main Na2I peaks as reference
ref_ts = peak_results[masses[0]].reset_index(drop=True)

# Identify spike scan times where Na2I intensity is outside acceptable bounds
ref_spike_time = ref_ts[
    (ref_ts['intensity'] &gt; Na2I_upper_bound) | 
    (ref_ts['intensity'] &lt; Na2I_lower_bound)
]['rt'].values

# Filter out all ions from scans with spike events
merged_spectrum_mzcal_filtered = merged_spectrum_mzcal.copy()
merged_spectrum_mzcal_filtered = merged_spectrum_mzcal_filtered[
    ~merged_spectrum_mzcal_filtered['rt'].isin(ref_spike_time)
].reset_index(drop=True)
{% endcodeblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-Main-Function"><a href="#3-2-Main-Function" class="headerlink" title="3.2 Main Function"></a>3.2 Main Function</h3><p>This section performs peak clustering using KDE and DBSCAN across the entire m/z range. The spectrum is processed in dynamic segments to balance resolution and performance. Key thresholds like clustering_thre, data_size_threshold, and optionally tof_add_ion_threshold control clustering sensitivity and filtering logic.</p>
<p>For Orbitrap-only datasets, you may remove tof_* functions and tof_add_ion_threshold settings entirely.<br>When handling very large datasets, comment out the pandas lines and use polars (pl.DataFrame) for better performance.</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">{% codeblock lang:python Main Clustering Loop %}
clustering_thre = 0.75 # Minimum clustering score to keep a cluster
data_size_threshold = 200 # Minimum number of points in one segment
tof_add_ion_threshold = 40 # [Optional] Only used when TOF data is available

import polars as pl
min_mz = round(merged_spectrum_mzcal['m/z'].min())
max_mz = round(merged_spectrum_mzcal['m/z'].max())

start = min_mz
merged_peak_list = []
missing_peak_list = []
start_time = time.time()

while start &lt; max_mz:
# Dynamically define m/z window based on data density
    end = mz_start_end_selection(
    merged_spectrum_mzcal_filtered, start,
    data_size_threshold, max_mz,
    max_window_width=5.0, delta_mz=0.5
    )

    # Main clustering and filtering function (can skip TOF if not needed)
    tof_list_df, missing_df = KDE_DBSCAN_clustering_filtering_in_batch_with_tof_data(
        merged_spectrum_mzcal_filtered,
        start, end, 
        kde_bandwidth, kde_percentile, eps_value, clustering_thre,
        tof_spectrum, tof_add_ion_threshold
    )

    merged_peak_list.append(tof_list_df)
    missing_peak_list.append(missing_df)
    print(f"Ions identified in m/z range {start} - {end}: {len(tof_list_df)} (added {len(missing_df)} ions)")

    start = end

merged_peak_list = pd.concat(merged_peak_list, ignore_index=True)
# merged_peak_list = pl.DataFrame(merged_peak_list)

missing_peak_list = pd.concat(missing_peak_list, ignore_index=True)
# missing_peak_list = pl.DataFrame(missing_peak_list)

# Final log message
print("Processing complete. All m/z ranges processed.")
overall_end_time = time.time()
total_time = time.time() - start_time
print(f"Total processing time: {total_time:.2f} seconds", f'Total ion length: {len(merged_peak_list)}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Example of the output:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ions identified in m/z range 41 - 46.0: 8 with 8 ions added
Ions identified in m/z range 46.0 - 47.5: 4 with 0 ions added
Ions identified in m/z range 47.5 - 52.5: 10 with 10 ions added
Ions identified in m/z range 52.5 - 57.5: 4 with 4 ions added
Ions identified in m/z range 57.5 - 62.5: 7 with 4 ions added
Ions identified in m/z range 62.5 - 67.5: 10 with 8 ions added
Ions identified in m/z range 67.5 - 71.5: 4 with 0 ions added
Ions identified in m/z range 71.5 - 75.5: 5 with 1 ions added
Ions identified in m/z range 75.5 - 80.5: 10 with 9 ions added
Ions identified in m/z range 80.5 - 83.5: 12 with 3 ions added
Ions identified in m/z range 83.5 - 85.5: 8 with 1 ions added
Ions identified in m/z range 85.5 - 88.0: 7 with 0 ions added
Ions identified in m/z range 88.0 - 89.5: 9 with 1 ions added
Ions identified in m/z range 89.5 - 93.0: 9 with 2 ions added
Ions identified in m/z range 93.0 - 95.5: 9 with 2 ions added
Ions identified in m/z range 95.5 - 97.5: 16 with 6 ions added
Ions identified in m/z range 97.5 - 100.5: 13 with 8 ions added
Ions identified in m/z range 100.5 - 104.5: 15 with 14 ions added
Ions identified in m/z range 104.5 - 107.5: 13 with 6 ions added
.......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-Post-checking-Visualizing-Orbitrap-TOF-added-peaks"><a href="#3-3-Post-checking-Visualizing-Orbitrap-TOF-added-peaks" class="headerlink" title="3.3 Post-checking (Visualizing Orbitrap &amp; TOF added peaks)"></a>3.3 Post-checking (Visualizing Orbitrap &amp; TOF added peaks)</h3><p>After clustering and filtering, this diagnostic plot helps visually confirm the presence of Orbitrap peaks and any TOF-inferred ions that were added back in. It can help regarding:</p>
<ol>
<li>Inspecting whether the Orbitrap-detected peaks align with TOF curve.</li>
<li>Verifying that added TOF peaks through mathmatical method are reasonable.</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fig = make_subplots(rows=1, cols=1, subplot_titles=('',),)
tar,step = 145,7
fit_ind = tof_spectrum[(tof_spectrum['mz'] &gt; tar) &amp; (tof_spectrum['mz'] &lt; tar+step)]
x_tof, y_tof, bl_tof = fit_ind['mz'], fit_ind['MS_av'], fit_ind['MS_BL']#,fit_ind['MS_av_blank']
fig.add_trace(go.Scatter(x=x_tof, y=y_tof, name='Raw', mode='lines',line=dict(color='#636efa'), hovertext='', hoverinfo="text+x+y"),
                  row=1, col=1)

orb_ind = merged_peak_list[((merged_peak_list['m.z']&gt;tar)&amp;(merged_peak_list['m.z']&lt;tar+step))&amp;(merged_peak_list['Note']  =='Orbi')]
x_orb   = orb_ind['m.z'].values

for xp in x_orb:
    index_ = (pd.Series(fit_ind['mz']) - xp).abs().idxmin()
    yp     = tof_spectrum['MS_av'].iloc[index_]
    fig.add_annotation(x=xp, y=yp, text='',
                   showarrow=True, arrowhead=4, arrowsize=1, arrowwidth=1.5,
                   arrowcolor='blue',
                   font=dict(family="Courier New, monospace", size=12, ),
                   ax=0, ay=-30*1,  # these values can be adjusted to position the annotation text
                   textangle=0, bgcolor="white",
                   row=1, col=1)        

tof_add_ind = merged_peak_list[((merged_peak_list['m.z']&gt;tar)&amp;(merged_peak_list['m.z']&lt;tar+step))&amp;(merged_peak_list['Note']!='Orbi')]
tof_add_ion_mz = tof_add_ind['m.z'].values
for xp in tof_add_ion_mz:
    index_ = (pd.Series(fit_ind['mz']) - xp).abs().idxmin()
    yp     = tof_spectrum['MS_av'].iloc[index_]
    fig.add_trace(go.Scatter(x=[xp], y=[yp], name='TOF add peaks', mode='markers', hovertext='', hoverinfo="text+x+y", marker=dict(size=9, color='red')),
              row=1, col=1)

fig.update_xaxes(title_text="m/z", showline=True, linecolor='black', range=[tar,tar+step], title_font={'size': 12}, )
fig.update_yaxes(title_text="Intensity", showline=True, linecolor='black', title_font={'size': 12}, )
fig.update_layout(
    height=450, 
    width=1200,  # Adjusted width to better accommodate five plots
    title_text="",
    plot_bgcolor='white',
    showlegend=False,
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/./images_rele/Fig.Orbitrak_ion_check_on_individual_window.png"></p>
<p>I also developed a lightweight web app, <strong>OrbiTrack Ion Mapper</strong>, to support interactive inspection of clustered peak results with the help of AI. It is available here: <a target="_blank" rel="noopener" href="https://teal-fenglisu-0aff35.netlify.app/">OrbiTrack Ion Mapper</a>    </p>
<p><img src="/./images_rele/Fig.Orbitrack_ion_mapper_demo.png"></p>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Python/">#Python</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Orbitrap/">#Orbitrap</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Mass-Spectrometry/">#Mass Spectrometry</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2024/10/24/35.%5BMS%5DOrbiTrack%20Dev%20Log%204_Enhancing_Peak_Coverage_via_TOF_Integration/">OrbiTrack Dev Log 4: TOF missing peaks adding</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2024/10/22/33.%5BMS%5DOrbiTrack_Dev_Log_2_MZ_calibration/">OrbiTrack Dev Log 2: Dynamic M/Z Calibration</a>
            
        </span>
    </div>
    
</article>




<div class="comments">
    <h3 class="title is-4">Comentarios</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'http://envhyf.github.io/2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/';
        this.page.identifier = '2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/';
        
        this.language = 'zh';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'taipingta' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2025 Hao Yufang&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/envhyf/">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Escribe algo..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Páginas',
                CATEGORIES: 'Categorías',
                TAGS: 'Tags',
                UNTITLED: '(Sin título)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>
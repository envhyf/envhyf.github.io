<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>OrbiTrack Dev Log 3: Ion Filtering and Clustering - 太平塔</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta name="description" content="After m&#x2F;z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m&#x2F;z values. To ensur">
<meta property="og:type" content="article">
<meta property="og:title" content="OrbiTrack Dev Log 3: Ion Filtering and Clustering">
<meta property="og:url" content="http://envhyf.github.io/2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/index.html">
<meta property="og:site_name" content="太平塔">
<meta property="og:description" content="After m&#x2F;z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m&#x2F;z values. To ensur">
<meta property="og:locale">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_1.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_2.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.DBSCAN_algorithm_results.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.Orbitrak_ion_check_on_individual_window.png">
<meta property="og:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.Orbitrack_ion_mapper_demo.png">
<meta property="article:published_time" content="2024-10-23T16:45:00.000Z">
<meta property="article:modified_time" content="2025-08-05T22:57:03.458Z">
<meta property="article:author" content="Hao Yufang">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Orbitrap">
<meta property="article:tag" content="Mass Spectrometry">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://envhyf.github.io/images/Orbitrack_log/Fig.KDE_algorithm_1.png">





<link rel="icon" href="/bugcatcher.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116955364-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-116955364-1');
</script>


    


<meta name="generator" content="Hexo 6.1.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    太平塔
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories/Research">Research</a>
            
            <a class="navbar-item "
               href="/categories/Tech">Tech</a>
            
            <a class="navbar-item "
               href="/categories/Life">Life</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Suche" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            OrbiTrack Dev Log 3: Ion Filtering and Clustering
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2024-10-23T16:45:00.000Z" itemprop="datePublished">10月 23 2024</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Research/">Research</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            16 分钟 lesen (Über 2337 Wörter)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>After m/z calibration, the next step is to align ions detected across different retention times that likely originate from the same chemical species but appear at slightly shifted m/z values. To ensure robust clustering, it’s important to first remove rare or noisy ions that could interfere with pattern recognition.</p>
<span id="more"></span>

<h2 id="1-Basic-principle"><a href="#1-Basic-principle" class="headerlink" title="1. Basic principle"></a>1. Basic principle</h2><p>We apply two types of filtering strategies onto Orbitrap MS1 data to isolate meaningful signals.    </p>
<p><strong>Density-Based Filtering (KDE)</strong><br>Kernel Density Estimation (KDE) is used to evaluate the local density around each m/z value:</p>
<ul>
<li>Low-density points are likely to represent noise or isolated random signals and are filtered out using a user-defined percentile threshold (default: 5%).</li>
<li>To balance accuracy and computational performance, the full m/z range is dynamically split into smaller chunks (e.g., 500 points), and KDE is applied to each chunk independently.<br>(Note: Since KDE has a time complexity of O(n²), chunking significantly reduces the computational burden. See slides below for more details.)</li>
</ul>
<p><img src="/images/Orbitrack_log/Fig.KDE_algorithm_1.png"></p>
<p><img src="/images/Orbitrack_log/Fig.KDE_algorithm_2.png"></p>
<p><strong>Ion Clustering (DBSCAN)</strong><br>The remaining m/z values after KDE filtering are grouped using the DBSCAN algorithm:</p>
<ul>
<li>DBSCAN identifies ion clusters based on spatial proximity, enabling detection of true ion peaks even with minor m/z drifts over time.</li>
<li>After clustering, a frequency threshold (e.g., ≥2% of scans) is applied to exclude unstable or sporadic clusters.</li>
</ul>
<p>For example, if a stable calibrant ion appears consistently in 100 scans, meaningful signals are expected to recur in at least a small fraction (e.g., ≥2 scans). This step removes random spikes that lack temporal consistency.</p>
<p>🟥 Note: The clustering_thre threshold is critical and should be carefully tuned based on the actual dataset and scanning strategy. It is highly recommended to validate the setting by checking the fitting quality in the post-analysis stage.</p>
<p><img src="/images/Orbitrack_log/Fig.DBSCAN_algorithm_results.png"></p>
<p>Besides, since the <code>OrbiTrack</code> will be also used for empowered the TOF peak list, it is </p>
<h2 id="2-Code-library"><a href="#2-Code-library" class="headerlink" title="2. Code library"></a>2. Code library</h2><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## Module 3 Filtering &amp; Clustering</span></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="title function_">mz_start_end_selection</span>(<span class="hljs-params">df, start, data_size_threshold, max_mz, max_window_width=<span class="hljs-number">2.0</span>, delta_mz=<span class="hljs-number">0.5</span></span>):</span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Dynamically determine the m/z end value starting from 'start' such that:</span></span><br><span class="line"><span class="hljs-string">    - The number of ions between start and end reaches data_size_threshold</span></span><br><span class="line"><span class="hljs-string">    - But the window size doesn't exceed max_window_width</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Parameters:</span></span><br><span class="line"><span class="hljs-string">        df: DataFrame with 'corrected_m/z' column</span></span><br><span class="line"><span class="hljs-string">        start: float, m/z start value</span></span><br><span class="line"><span class="hljs-string">        data_size_threshold: int, minimum number of ions in window</span></span><br><span class="line"><span class="hljs-string">        max_mz: float, global m/z limit</span></span><br><span class="line"><span class="hljs-string">        max_window_width: float, max allowed width of m/z window</span></span><br><span class="line"><span class="hljs-string">        delta_mz: float, step size for expansion</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Returns:</span></span><br><span class="line"><span class="hljs-string">        end: float, selected m/z end value</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    current_mz_start = start</span><br><span class="line">    current_mz_end = start + delta_mz</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> current_mz_end &lt; max_mz:</span><br><span class="line">        condition = (df[<span class="hljs-string">'corrected_m/z'</span>] &gt;= current_mz_start) &amp; (df[<span class="hljs-string">'corrected_m/z'</span>] &lt; current_mz_end)</span><br><span class="line">        current_mz_values = df[condition]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># If threshold met, return current end</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current_mz_values) &gt;= data_size_threshold:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># If window exceeds max width, break</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (current_mz_end - current_mz_start) &gt;= max_window_width:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line"></span><br><span class="line">        current_mz_end += delta_mz</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(current_mz_end, max_mz)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">def</span> <span class="title function_">filter_asymmetric_peaks</span>(<span class="hljs-params">peaks, props, y_data, left_thre=<span class="hljs-number">500</span>, right_thre=<span class="hljs-number">500</span></span>):</span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    Remove peaks with weak prominence on both sides or very asymmetric shoulder peaks.</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Parameters:</span></span><br><span class="line"><span class="hljs-string">    - peaks: array of peak indices</span></span><br><span class="line"><span class="hljs-string">    - props: properties returned by find_peaks</span></span><br><span class="line"><span class="hljs-string">    - y_data: original signal array (e.g., y_tof)</span></span><br><span class="line"><span class="hljs-string">    - left_thre, right_thre: minimum prominence required on each side</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">    Returns:</span></span><br><span class="line"><span class="hljs-string">    - filtered_peaks: list of retained peak indices</span></span><br><span class="line"><span class="hljs-string">    """</span></span><br><span class="line">    filtered_peaks = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i, pk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(peaks):</span><br><span class="line">        y_pk = y_data[pk]</span><br><span class="line">        left_valley = y_data[props[<span class="hljs-string">'left_bases'</span>][i]]</span><br><span class="line">        right_valley = y_data[props[<span class="hljs-string">'right_bases'</span>][i]]</span><br><span class="line"></span><br><span class="line">        left_prom = y_pk - left_valley</span><br><span class="line">        right_prom = y_pk - right_valley</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># Keep only if either side is strong enough</span></span><br><span class="line">        <span class="hljs-keyword">if</span> left_prom &gt;= left_thre <span class="hljs-keyword">or</span> right_prom &gt;= right_thre:</span><br><span class="line">            filtered_peaks.append(pk)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> np.array(filtered_peaks)</span><br><span class="line"><span class="hljs-keyword">def</span> <span class="title function_">KDE_DBSCAN_clustering_filtering_in_batch_with_tof_data</span>(<span class="hljs-params">df, start, end,</span></span><br><span class="line"><span class="hljs-params">        kde_bandwidth, kde_percentile, eps_value, clustering_thre,</span></span><br><span class="line"><span class="hljs-params">        tof_spectrum, tof_add_ion_threshold</span>):</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 1. Subset Orbitrap spectrum</span></span><br><span class="line">    condition = (df[<span class="hljs-string">'corrected_m/z'</span>] &gt; start) &amp; (df[<span class="hljs-string">'corrected_m/z'</span>] &lt; end)</span><br><span class="line">    ind_mz_df = df[condition].sort_values(by=<span class="hljs-string">'corrected_m/z'</span>).reset_index(drop=<span class="hljs-literal">True</span>)</span><br><span class="line">    ind_mz = ind_mz_df[<span class="hljs-string">'corrected_m/z'</span>].values</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ind_mz) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> pd.DataFrame(), pd.DataFrame()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 2. KDE filter</span></span><br><span class="line">    kde = KernelDensity(bandwidth=kde_bandwidth)</span><br><span class="line">    kde.fit(ind_mz.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span><br><span class="line">    density_scores = np.exp(kde.score_samples(ind_mz.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))</span><br><span class="line">    threshold = np.percentile(density_scores, kde_percentile)</span><br><span class="line">    filtered_mz_values = ind_mz[density_scores &gt; threshold]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(filtered_mz_values) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> pd.DataFrame(), pd.DataFrame()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 3. DBSCAN clustering</span></span><br><span class="line">    eps = eps_value * start / <span class="hljs-number">1E6</span></span><br><span class="line">    min_samples = <span class="hljs-number">1</span></span><br><span class="line">    db = DBSCAN(eps=eps, min_samples=min_samples).fit(filtered_mz_values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span><br><span class="line">    labels = db.labels_</span><br><span class="line"></span><br><span class="line">    clusters = {}</span><br><span class="line">    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> np.unique(labels):</span><br><span class="line">        <span class="hljs-keyword">if</span> label != -<span class="hljs-number">1</span>:</span><br><span class="line">            indices = np.where(labels == label)[<span class="hljs-number">0</span>]</span><br><span class="line">            cluster_values = filtered_mz_values[indices].flatten()</span><br><span class="line">            centroid = np.mean(cluster_values)</span><br><span class="line">            clusters[centroid] = cluster_values.tolist()</span><br><span class="line"></span><br><span class="line">    cluster_filtered = {</span><br><span class="line">        c: v <span class="hljs-keyword">for</span> c, v <span class="hljs-keyword">in</span> clusters.items()</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v) &gt; showing_freq * clustering_thre</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 4. Orbitrap peaks → unified format</span></span><br><span class="line">    orbitrap_records = []</span><br><span class="line">    mz_to_intensity = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(ind_mz_df[<span class="hljs-string">'corrected_m/z'</span>], ind_mz_df[<span class="hljs-string">'intensity'</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># Pull TOF data for the current window</span></span><br><span class="line">    fit_ind = tof_spectrum[(tof_spectrum[<span class="hljs-string">'mz'</span>] &gt; start) &amp; (tof_spectrum[<span class="hljs-string">'mz'</span>] &lt; end)].reset_index(drop = <span class="hljs-literal">True</span>)</span><br><span class="line">    x_tof, y_tof = fit_ind[<span class="hljs-string">'mz'</span>], fit_ind[<span class="hljs-string">'MS_av'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> centroid, mz_list <span class="hljs-keyword">in</span> cluster_filtered.items():</span><br><span class="line">        int_orbi = np.mean([mz_to_intensity[mz] <span class="hljs-keyword">for</span> mz <span class="hljs-keyword">in</span> mz_list])</span><br><span class="line">        index_tof = (x_tof - centroid).<span class="hljs-built_in">abs</span>().idxmin() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x_tof.empty <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></span><br><span class="line">        int_tof =   y_tof.iloc[index_tof] <span class="hljs-keyword">if</span> index_tof <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> np.nan</span><br><span class="line"></span><br><span class="line">        orbitrap_records.append({</span><br><span class="line">            <span class="hljs-string">'m.z'</span>: centroid,</span><br><span class="line">            <span class="hljs-string">'int_in_orbi'</span>: int_orbi,</span><br><span class="line">            <span class="hljs-string">'int_in_tof'</span>: int_tof,</span><br><span class="line">            <span class="hljs-string">'Note'</span>: <span class="hljs-string">'Orbi'</span></span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">    cluster_df = pd.DataFrame(orbitrap_records)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 5. TOF-only peak detection</span></span><br><span class="line">    </span><br><span class="line">    peaks, props = find_peaks(y_tof, prominence=<span class="hljs-number">200</span>, distance=<span class="hljs-number">5</span>, width=<span class="hljs-number">2</span>)</span><br><span class="line">    filtered_peaks = filter_asymmetric_peaks(peaks, props, y_tof, left_thre=<span class="hljs-number">500</span>, right_thre=<span class="hljs-number">500</span>)</span><br><span class="line"></span><br><span class="line">    peak_mz = x_tof[filtered_peaks]</span><br><span class="line">    ppm_threshold = tof_add_ion_threshold</span><br><span class="line">    missing_records = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> peak <span class="hljs-keyword">in</span> peak_mz:</span><br><span class="line">        allowed_diff = peak * ppm_threshold / <span class="hljs-number">1e6</span></span><br><span class="line">        matched_in_cluster = <span class="hljs-built_in">any</span>(np.<span class="hljs-built_in">abs</span>(cluster_df[<span class="hljs-string">'m.z'</span>] - peak) &lt;= allowed_diff) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cluster_df.empty <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-comment"># matched_in_raw = any(np.abs(ind_mz_df['corrected_m/z'] - peak) &lt;= allowed_diff) if not ind_mz_df.empty else False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (matched_in_cluster):</span><br><span class="line">            <span class="hljs-comment"># Estimate Orbitrap intensity only if possible</span></span><br><span class="line">            int_orbi = np.nan</span><br><span class="line">            int_tof = y_tof.iloc[(x_tof - peak).<span class="hljs-built_in">abs</span>().idxmin()]</span><br><span class="line">            missing_records.append({</span><br><span class="line">                <span class="hljs-string">'m.z'</span>: peak,</span><br><span class="line">                <span class="hljs-string">'int_in_orbi'</span>: int_orbi,</span><br><span class="line">                <span class="hljs-string">'int_in_tof'</span>: int_tof,</span><br><span class="line">                <span class="hljs-string">'Note'</span>: <span class="hljs-string">'Missing Peak'</span></span><br><span class="line">            })</span><br><span class="line"></span><br><span class="line">    missing_df = pd.DataFrame(missing_records)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 6. Merge both</span></span><br><span class="line">    combined_df = pd.concat([cluster_df, missing_df], ignore_index=<span class="hljs-literal">True</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(combined_df) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> pd.DataFrame(), pd.DataFrame()</span><br><span class="line">    combined_df = combined_df.sort_values(by=<span class="hljs-string">'m.z'</span>).reset_index(drop=<span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> combined_df, missing_df</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Execution-and-Output-Parameters"><a href="#3-Execution-and-Output-Parameters" class="headerlink" title="3. Execution and Output Parameters"></a>3. Execution and Output Parameters</h2><h3 id="3-1-Pre-filtering"><a href="#3-1-Pre-filtering" class="headerlink" title="3.1 Pre-filtering"></a>3.1 Pre-filtering</h3><p>Before applying the main filtering and clustering procedures, I noticed that certain segment scans showed abnormally high intensities of primary ions from the ion source — in our case, NaI–Na⁺ as the sodium-adducted NaI. These “spike scans” often featured very strong Na₂I signals, while all other ions were poorly detected, likely due to temporary spray instability or ESI plume fluctuations.</p>
<p>To address this, we define both a <code>Na2I_upper_bound</code> and a <code>Na2I_lower_bound</code>. These thresholds help identify segment scans where Na₂I signal is either abnormally high or too weak (e.g., unstable spray), which is particularly important for online measurements where ion intensity is crucial for interpretation.</p>
<p>Using the pre-defined <code>find_peak_near_mass_after_mzcal</code> function, we search for peak intensities of selected sodium-related masses. If any of them fall outside the defined bounds, we remove all ions from those time points before further processing.</p>
<figure class="highlight plaintext hljs"><figcaption><span>codeblock lang:python %}</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Define reference masses related to NaI signals</span><br><span class="line">Na2I_lower_bound, Na2I_upper_bound = 0, 50 * 1E6  # Filter to remove bad air-beam ions</span><br><span class="line">masses = [172.88347, 166.9163, 185.0420]  # Na2I and some other ions if you think are essential</span><br><span class="line">peak_results = {}</span><br><span class="line"></span><br><span class="line"># Locate peaks near the reference masses</span><br><span class="line">for mass in masses:</span><br><span class="line">    peaks = find_peak_near_mass_after_mzcal(merged_spectrum_mzcal, mass, tolerance_ppm)</span><br><span class="line">    peak_results[mass] = peaks</span><br><span class="line"></span><br><span class="line"># Use one of the main Na2I peaks as reference</span><br><span class="line">ref_ts = peak_results[masses[0]].reset_index(drop=True)</span><br><span class="line"></span><br><span class="line"># Identify spike scan times where Na2I intensity is outside acceptable bounds</span><br><span class="line">ref_spike_time = ref_ts[</span><br><span class="line">    (ref_ts['intensity'] &gt; Na2I_upper_bound) | </span><br><span class="line">    (ref_ts['intensity'] &lt; Na2I_lower_bound)</span><br><span class="line">]['rt'].values</span><br><span class="line"></span><br><span class="line"># Filter out all ions from scans with spike events</span><br><span class="line">merged_spectrum_mzcal_filtered = merged_spectrum_mzcal.copy()</span><br><span class="line">merged_spectrum_mzcal_filtered = merged_spectrum_mzcal_filtered[</span><br><span class="line">    ~merged_spectrum_mzcal_filtered['rt'].isin(ref_spike_time)</span><br><span class="line">].reset_index(drop=True)</span><br><span class="line">{% endcodeblock %}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-Main-Function"><a href="#3-2-Main-Function" class="headerlink" title="3.2 Main Function"></a>3.2 Main Function</h3><p>This section performs peak clustering using KDE and DBSCAN across the entire m/z range. The spectrum is processed in dynamic segments to balance resolution and performance. Key thresholds like clustering_thre, data_size_threshold, and optionally tof_add_ion_threshold control clustering sensitivity and filtering logic.</p>
<p>For Orbitrap-only datasets, you may remove tof_* functions and tof_add_ion_threshold settings entirely.<br>When handling very large datasets, comment out the pandas lines and use polars (pl.DataFrame) for better performance.</p>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">{% codeblock lang:python Main Clustering Loop %}</span><br><span class="line">clustering_thre = <span class="hljs-number">0.75</span> <span class="hljs-comment"># Minimum clustering score to keep a cluster</span></span><br><span class="line">data_size_threshold = <span class="hljs-number">200</span> <span class="hljs-comment"># Minimum number of points in one segment</span></span><br><span class="line">tof_add_ion_threshold = <span class="hljs-number">40</span> <span class="hljs-comment"># [Optional] Only used when TOF data is available</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> polars <span class="hljs-keyword">as</span> pl</span><br><span class="line">min_mz = <span class="hljs-built_in">round</span>(merged_spectrum_mzcal[<span class="hljs-string">'m/z'</span>].<span class="hljs-built_in">min</span>())</span><br><span class="line">max_mz = <span class="hljs-built_in">round</span>(merged_spectrum_mzcal[<span class="hljs-string">'m/z'</span>].<span class="hljs-built_in">max</span>())</span><br><span class="line"></span><br><span class="line">start = min_mz</span><br><span class="line">merged_peak_list = []</span><br><span class="line">missing_peak_list = []</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> start &lt; max_mz:</span><br><span class="line"><span class="hljs-comment"># Dynamically define m/z window based on data density</span></span><br><span class="line">    end = mz_start_end_selection(</span><br><span class="line">    merged_spectrum_mzcal_filtered, start,</span><br><span class="line">    data_size_threshold, max_mz,</span><br><span class="line">    max_window_width=<span class="hljs-number">5.0</span>, delta_mz=<span class="hljs-number">0.5</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># Main clustering and filtering function (can skip TOF if not needed)</span></span><br><span class="line">    tof_list_df, missing_df = KDE_DBSCAN_clustering_filtering_in_batch_with_tof_data(</span><br><span class="line">        merged_spectrum_mzcal_filtered,</span><br><span class="line">        start, end, </span><br><span class="line">        kde_bandwidth, kde_percentile, eps_value, clustering_thre,</span><br><span class="line">        tof_spectrum, tof_add_ion_threshold</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    merged_peak_list.append(tof_list_df)</span><br><span class="line">    missing_peak_list.append(missing_df)</span><br><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Ions identified in m/z range <span class="hljs-subst">{start}</span> - <span class="hljs-subst">{end}</span>: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(tof_list_df)}</span> (added <span class="hljs-subst">{<span class="hljs-built_in">len</span>(missing_df)}</span> ions)"</span>)</span><br><span class="line"></span><br><span class="line">    start = end</span><br><span class="line"></span><br><span class="line">merged_peak_list = pd.concat(merged_peak_list, ignore_index=<span class="hljs-literal">True</span>)</span><br><span class="line"><span class="hljs-comment"># merged_peak_list = pl.DataFrame(merged_peak_list)</span></span><br><span class="line"></span><br><span class="line">missing_peak_list = pd.concat(missing_peak_list, ignore_index=<span class="hljs-literal">True</span>)</span><br><span class="line"><span class="hljs-comment"># missing_peak_list = pl.DataFrame(missing_peak_list)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Final log message</span></span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Processing complete. All m/z ranges processed."</span>)</span><br><span class="line">overall_end_time = time.time()</span><br><span class="line">total_time = time.time() - start_time</span><br><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">f"Total processing time: <span class="hljs-subst">{total_time:<span class="hljs-number">.2</span>f}</span> seconds"</span>, <span class="hljs-string">f'Total ion length: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(merged_peak_list)}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>Example of the output:</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 41 - 46.0: 8 with 8 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 46.0 - 47.5: 4 with 0 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 47.5 - 52.5: 10 with 10 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 52.5 - 57.5: 4 with 4 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 57.5 - 62.5: 7 with 4 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 62.5 - 67.5: 10 with 8 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 67.5 - 71.5: 4 with 0 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 71.5 - 75.5: 5 with 1 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 75.5 - 80.5: 10 with 9 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 80.5 - 83.5: 12 with 3 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 83.5 - 85.5: 8 with 1 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 85.5 - 88.0: 7 with 0 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 88.0 - 89.5: 9 with 1 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 89.5 - 93.0: 9 with 2 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 93.0 - 95.5: 9 with 2 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 95.5 - 97.5: 16 with 6 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 97.5 - 100.5: 13 with 8 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 100.5 - 104.5: 15 with 14 ions added</span><br><span class="line">Ions identified <span class="hljs-keyword">in</span> m/z range 104.5 - 107.5: 13 with 6 ions added</span><br><span class="line">.......</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-3-Post-checking-Visualizing-Orbitrap-TOF-added-peaks"><a href="#3-3-Post-checking-Visualizing-Orbitrap-TOF-added-peaks" class="headerlink" title="3.3 Post-checking (Visualizing Orbitrap &amp; TOF added peaks)"></a>3.3 Post-checking (Visualizing Orbitrap &amp; TOF added peaks)</h3><p>After clustering and filtering, this diagnostic plot helps visually confirm the presence of Orbitrap peaks and any TOF-inferred ions that were added back in. It can help regarding:</p>
<ol>
<li>Inspecting whether the Orbitrap-detected peaks align with TOF curve.</li>
<li>Verifying that added TOF peaks through mathmatical method are reasonable.</li>
</ol>
<figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">fig = make_subplots(rows=<span class="hljs-number">1</span>, cols=<span class="hljs-number">1</span>, subplot_titles=(<span class="hljs-string">''</span>,),)</span><br><span class="line">tar,step = <span class="hljs-number">145</span>,<span class="hljs-number">7</span></span><br><span class="line">fit_ind = tof_spectrum[(tof_spectrum[<span class="hljs-string">'mz'</span>] &gt; tar) &amp; (tof_spectrum[<span class="hljs-string">'mz'</span>] &lt; tar+step)]</span><br><span class="line">x_tof, y_tof, bl_tof = fit_ind[<span class="hljs-string">'mz'</span>], fit_ind[<span class="hljs-string">'MS_av'</span>], fit_ind[<span class="hljs-string">'MS_BL'</span>]<span class="hljs-comment">#,fit_ind['MS_av_blank']</span></span><br><span class="line">fig.add_trace(go.Scatter(x=x_tof, y=y_tof, name=<span class="hljs-string">'Raw'</span>, mode=<span class="hljs-string">'lines'</span>,line=<span class="hljs-built_in">dict</span>(color=<span class="hljs-string">'#636efa'</span>), hovertext=<span class="hljs-string">''</span>, hoverinfo=<span class="hljs-string">"text+x+y"</span>),</span><br><span class="line">                  row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">orb_ind = merged_peak_list[((merged_peak_list[<span class="hljs-string">'m.z'</span>]&gt;tar)&amp;(merged_peak_list[<span class="hljs-string">'m.z'</span>]&lt;tar+step))&amp;(merged_peak_list[<span class="hljs-string">'Note'</span>]  ==<span class="hljs-string">'Orbi'</span>)]</span><br><span class="line">x_orb   = orb_ind[<span class="hljs-string">'m.z'</span>].values</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> xp <span class="hljs-keyword">in</span> x_orb:</span><br><span class="line">    index_ = (pd.Series(fit_ind[<span class="hljs-string">'mz'</span>]) - xp).<span class="hljs-built_in">abs</span>().idxmin()</span><br><span class="line">    yp     = tof_spectrum[<span class="hljs-string">'MS_av'</span>].iloc[index_]</span><br><span class="line">    fig.add_annotation(x=xp, y=yp, text=<span class="hljs-string">''</span>,</span><br><span class="line">                   showarrow=<span class="hljs-literal">True</span>, arrowhead=<span class="hljs-number">4</span>, arrowsize=<span class="hljs-number">1</span>, arrowwidth=<span class="hljs-number">1.5</span>,</span><br><span class="line">                   arrowcolor=<span class="hljs-string">'blue'</span>,</span><br><span class="line">                   font=<span class="hljs-built_in">dict</span>(family=<span class="hljs-string">"Courier New, monospace"</span>, size=<span class="hljs-number">12</span>, ),</span><br><span class="line">                   ax=<span class="hljs-number">0</span>, ay=-<span class="hljs-number">30</span>*<span class="hljs-number">1</span>,  <span class="hljs-comment"># these values can be adjusted to position the annotation text</span></span><br><span class="line">                   textangle=<span class="hljs-number">0</span>, bgcolor=<span class="hljs-string">"white"</span>,</span><br><span class="line">                   row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span>)        </span><br><span class="line"></span><br><span class="line">tof_add_ind = merged_peak_list[((merged_peak_list[<span class="hljs-string">'m.z'</span>]&gt;tar)&amp;(merged_peak_list[<span class="hljs-string">'m.z'</span>]&lt;tar+step))&amp;(merged_peak_list[<span class="hljs-string">'Note'</span>]!=<span class="hljs-string">'Orbi'</span>)]</span><br><span class="line">tof_add_ion_mz = tof_add_ind[<span class="hljs-string">'m.z'</span>].values</span><br><span class="line"><span class="hljs-keyword">for</span> xp <span class="hljs-keyword">in</span> tof_add_ion_mz:</span><br><span class="line">    index_ = (pd.Series(fit_ind[<span class="hljs-string">'mz'</span>]) - xp).<span class="hljs-built_in">abs</span>().idxmin()</span><br><span class="line">    yp     = tof_spectrum[<span class="hljs-string">'MS_av'</span>].iloc[index_]</span><br><span class="line">    fig.add_trace(go.Scatter(x=[xp], y=[yp], name=<span class="hljs-string">'TOF add peaks'</span>, mode=<span class="hljs-string">'markers'</span>, hovertext=<span class="hljs-string">''</span>, hoverinfo=<span class="hljs-string">"text+x+y"</span>, marker=<span class="hljs-built_in">dict</span>(size=<span class="hljs-number">9</span>, color=<span class="hljs-string">'red'</span>)),</span><br><span class="line">              row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">fig.update_xaxes(title_text=<span class="hljs-string">"m/z"</span>, showline=<span class="hljs-literal">True</span>, linecolor=<span class="hljs-string">'black'</span>, <span class="hljs-built_in">range</span>=[tar,tar+step], title_font={<span class="hljs-string">'size'</span>: <span class="hljs-number">12</span>}, )</span><br><span class="line">fig.update_yaxes(title_text=<span class="hljs-string">"Intensity"</span>, showline=<span class="hljs-literal">True</span>, linecolor=<span class="hljs-string">'black'</span>, title_font={<span class="hljs-string">'size'</span>: <span class="hljs-number">12</span>}, )</span><br><span class="line">fig.update_layout(</span><br><span class="line">    height=<span class="hljs-number">450</span>, </span><br><span class="line">    width=<span class="hljs-number">1200</span>,  <span class="hljs-comment"># Adjusted width to better accommodate five plots</span></span><br><span class="line">    title_text=<span class="hljs-string">""</span>,</span><br><span class="line">    plot_bgcolor=<span class="hljs-string">'white'</span>,</span><br><span class="line">    showlegend=<span class="hljs-literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/Orbitrack_log/Fig.Orbitrak_ion_check_on_individual_window.png"></p>
<p>I also developed a lightweight web app, <strong>OrbiTrack Ion Mapper</strong>, to support interactive inspection of clustered peak results with the help of AI. It is available here: <a target="_blank" rel="noopener" href="https://teal-fenglisu-0aff35.netlify.app/">OrbiTrack Ion Mapper</a>    </p>
<p><img src="/images/Orbitrack_log/Fig.Orbitrack_ion_mapper_demo.png"></p>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Python/">#Python</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Orbitrap/">#Orbitrap</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Mass-Spectrometry/">#Mass Spectrometry</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2024/10/24/35.%5BMS%5DOrbiTrack%20Dev%20Log%204_Enhancing_Peak_Coverage_via_TOF_Integration/">OrbiTrack Dev Log 4: TOF Missing Peaks Adding</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2024/10/22/33.%5BMS%5DOrbiTrack_Dev_Log_2_MZ_calibration/">OrbiTrack Dev Log 2: Dynamic M/Z Calibration</a>
            
        </span>
    </div>
    
</article>




<div class="comments">
    <h3 class="title is-4">Kommentare</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'http://envhyf.github.io/2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/';
        this.page.identifier = '2024/10/23/34.[MS]OrbiTrack_Dev_Log_3_Ion_Filtering_and_Clustering/';
        
        this.language = 'zh';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'taipingta' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2025 Hao Yufang&nbsp;
                Разработано на базе <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Suche etwas..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Seiten',
                CATEGORIES: 'Kategorien',
                TAGS: 'Tags',
                UNTITLED: '(Sans Titre)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>